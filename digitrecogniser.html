<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-M">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handwritten Digit Recognizer</title>
    <!-- 1. Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Load TensorFlow.js (Core ML library) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <!-- 3. Load the MNIST data library -->
    <script src="https://storage.googleapis.com/tfjs-examples/mnist-core/data.js"></script>
    
    <style>
        /* Custom style for the drawing canvas */
        #main-canvas {
            touch-action: none; /* Prevents page scrolling while drawing on touch devices */
        }
        /* Simple bar chart styling */
        .prob-bar-container {
            height: 20px;
            background-color: #e5e7eb; /* gray-200 */
        }
        .prob-bar {
            height: 100%;
            background-color: #3b82f6; /* blue-500 */
            transition: width 0.3s ease-in-out;
        }
    </style>
</head>
<body class="font-sans antialiased">
    <div class="bg-gray-900 text-white min-h-screen flex items-center justify-center p-4">
        
        <div class="bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-2xl w-full max-w-4xl grid grid-cols-1 lg:grid-cols-2 gap-8">
            
            <!-- Left Column: Controls & Canvas -->
            <div class="flex flex-col space-y-6">
                <h1 class="text-3xl font-bold text-center text-blue-400">ML Digit Recognizer</h1>
                
                <!-- Status & Training -->
                <div class="bg-gray-700 p-4 rounded-lg">
                    <button id="train-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                        Load Data & Train Model
                    </button>
                    <p id="status" class="text-center text-gray-400 mt-3 text-sm">
                        Click the button to start.
                    </p>
                </div>

                <!-- Drawing Area -->
                <div class="flex flex-col items-center">
                    <p class="text-lg font-semibold mb-2">Draw a digit (0-9) below</p>
                    <!-- This canvas is for drawing. It's larger for easier use. -->
                    <canvas id="main-canvas" width="280" height="280" class="bg-white rounded-lg shadow-inner cursor-crosshair border-4 border-gray-700"></canvas>
                    <!-- This hidden canvas is 28x28, the size the model expects. -->
                    <canvas id="hidden-canvas" width="28" height="28" class="hidden"></canvas>
                </div>

                <!-- Control Buttons -->
                <div class="grid grid-cols-2 gap-4">
                    <button id="predict-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        Predict
                    </button>
                    <button id="clear-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300">
                        Clear
                    </button>
                </div>
            </div>

            <!-- Right Column: Results -->
            <div class="flex flex-col justify-center items-center space-y-6 bg-gray-700 p-6 rounded-lg">
                <h2 class="text-2xl font-semibold text-gray-200">Prediction</h2>
                
                <!-- Main Prediction Result -->
                <div class="flex items-center justify-center bg-gray-800 rounded-full w-48 h-48 border-8 border-blue-500">
                    <p id="result-text" class="text-8xl font-bold text-white">-</p>
                </div>

                <!-- Probabilities Chart -->
                <div class="w-full max-w-sm space-y-2">
                    <h3 class="text-lg font-medium text-gray-300 text-center">Probabilities</h3>
                    <!-- We'll create 10 bars, one for each digit -->
                    <div id="probabilities-container" class="space-y-1.5">
                        <!-- Bars will be dynamically generated by JS -->
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script type="module">
        // --- Globals ---
        let model;
        let mnistData;
        let canvas, ctx, hiddenCanvas, hiddenCtx;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // --- DOM Elements ---
        const trainButton = document.getElementById('train-button');
        const predictButton = document.getElementById('predict-button');
        const clearButton = document.getElementById('clear-button');
        const statusText = document.getElementById('status');
        const resultText = document.getElementById('result-text');
        const probsContainer = document.getElementById('probabilities-container');

        // --- Model & Data Constants ---
        const TRAIN_DATA_SIZE = 8000;
        const TEST_DATA_SIZE = 2000;
        
        // --- Initialization ---
        function init() {
            // Set up main drawing canvas
            canvas = document.getElementById('main-canvas');
            ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.strokeStyle = '#000000'; // Black ink
            ctx.lineWidth = 20; // Nice thick line
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Set up hidden 28x28 canvas
            hiddenCanvas = document.getElementById('hidden-canvas');
            hiddenCtx = hiddenCanvas.getContext('2d', { willReadFrequently: true });

            // Initialize probability bars
            for (let i = 0; i < 10; i++) {
                const barHtml = `
                    <div class="flex items-center space-x-2">
                        <span class="font-mono text-lg text-white w-4">${i}</span>
                        <div class="prob-bar-container w-full rounded">
                            <div id="prob-bar-${i}" class="prob-bar rounded" style="width: 0%;"></div>
                        </div>
                        <span id="prob-val-${i}" class="font-mono text-sm text-gray-400 w-10 text-right">0%</span>
                    </div>
                `;
                probsContainer.innerHTML += barHtml;
            }

            addEventListeners();
            clearCanvas(); // Ensure canvas is white initially
        }

        // --- Event Listeners ---
        function addEventListeners() {
            trainButton.addEventListener('click', runTraining);
            predictButton.addEventListener('click', predict);
            clearButton.addEventListener('click', clearCanvas);

            // Drawing Listeners (Mouse)
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            // Drawing Listeners (Touch)
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scrolling
                const touch = e.touches[0];
                startDrawing(getTouchPos(canvas, touch));
            });
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault(); // Prevent scrolling
                const touch = e.touches[0];
                draw(getTouchPos(canvas, touch));
            });
            canvas.addEventListener('touchend', stopDrawing);
        }

        // --- Canvas Drawing Functions ---
        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }

        function draw(e) {
            if (!isDrawing) return;
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function clearCanvas() {
            // Clear main canvas (set to white)
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Clear hidden canvas
            hiddenCtx.clearRect(0, 0, hiddenCanvas.width, hiddenCanvas.height);
            
            // Reset results
            resultText.innerText = '-';
            for (let i = 0; i < 10; i++) {
                document.getElementById(`prob-bar-${i}`).style.width = '0%';
                document.getElementById(`prob-val-${i}`).innerText = '0%';
            }
        }
        
        // Helper to get touch position relative to canvas
        function getTouchPos(canvasDom, touchEvent) {
            const rect = canvasDom.getBoundingClientRect();
            return {
                offsetX: touchEvent.clientX - rect.left,
                offsetY: touchEvent.clientY - rect.top
            };
        }

        // --- Machine Learning Functions ---

        /**
         * Defines the Convolutional Neural Network (CNN) model.
         */
        function createModel() {
            const model = tf.sequential();

            // 1. First Convolutional Layer
            model.add(tf.layers.conv2d({
                inputShape: [28, 28, 1], // 28x28 pixels, 1 color channel
                kernelSize: 5,
                filters: 8,
                strides: 1,
                activation: 'relu',
                kernelInitializer: 'varianceScaling'
            }));

            // 2. Max Pooling Layer
            model.add(tf.layers.maxPooling2d({ poolSize: [2, 2], strides: [2, 2] }));

            // 3. Second Convolutional Layer
            model.add(tf.layers.conv2d({
                kernelSize: 5,
                filters: 16,
                strides: 1,
                activation: 'relu',
                kernelInitializer: 'varianceScaling'
            }));

            // 4. Max Pooling Layer
            model.add(tf.layers.maxPooling2d({ poolSize: [2, 2], strides: [2, 2] }));

            // 5. Flatten Layer: Convert 2D image data to 1D vector
            model.add(tf.layers.flatten());

            // 6. Dense (Fully Connected) Layer for classification
            model.add(tf.layers.dense({
                units: 10, // 10 output units (for digits 0-9)
                kernelInitializer: 'varianceScaling',
                activation: 'softmax' // Output probabilities
            }));

            // Compile the model
            model.compile({
                optimizer: tf.train.adam(),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });

            return model;
        }

        /**
         * Main function to load data, create, and train the model.
         */
        async function runTraining() {
            trainButton.disabled = true;
            statusText.innerText = 'Loading MNIST data...';

            // Load the data
            mnistData = new MnistData();
            await mnistData.load();

            statusText.innerText = 'Creating model...';
            model = createModel();
            
            statusText.innerText = `Training model... (on ${TRAIN_DATA_SIZE} samples)`;
            
            // Get the training data
            const [trainXs, trainYs] = tf.tidy(() => {
                const d = mnistData.nextTrainBatch(TRAIN_DATA_SIZE);
                return [
                    d.xs.reshape([TRAIN_DATA_SIZE, 28, 28, 1]), // Reshape to [batch, height, width, channels]
                    d.labels
                ];
            });

            // Get the test data
            const [testXs, testYs] = tf.tidy(() => {
                const d = mnistData.nextTestBatch(TEST_DATA_SIZE);
                return [
                    d.xs.reshape([TEST_DATA_SIZE, 28, 28, 1]),
                    d.labels
                ];
            });

            // Train the model
            await model.fit(trainXs, trainYs, {
                batchSize: 512,
                validationData: [testXs, testYs],
                epochs: 10,
                shuffle: true,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        statusText.innerText = `Training... Epoch ${epoch + 1}/10 | Accuracy: ${(logs.val_acc * 100).toFixed(2)}%`;
                        console.log(`Epoch ${epoch}: accuracy = ${logs.val_acc}`);
                    }
                }
            });

            // Cleanup tensors
            tf.dispose([trainXs, trainYs, testXs, testYs]);
            
            statusText.innerText = 'Training complete! Draw a digit and click "Predict".';
            predictButton.disabled = false; // Enable prediction
            trainButton.innerText = 'Retrain Model';
            trainButton.disabled = false;
        }

        /**
         * Processes the canvas image and feeds it to the model for prediction.
         */
        async function predict() {
            if (!model) {
                alert("Please train the model first!");
                return;
            }

            // 1. Get the image data from the main canvas
            // We need to preprocess it to match the MNIST format:
            // 28x28 pixels, grayscale, inverted (black background, white digit), normalized (0-1)
            
            const tensor = tf.tidy(() => {
                // a. Draw the 280x280 canvas onto the 28x28 hidden canvas (downsampling)
                hiddenCtx.drawImage(canvas, 0, 0, 28, 28);
                
                // b. Get the image data from the 28x28 canvas
                const imageData = hiddenCtx.getImageData(0, 0, 28, 28);
                
                // c. Convert to grayscale tensor. MNIST data is white-on-black (0-255).
                // Our canvas is black-on-white. The alpha channel (imageData.data[i*4 + 3])
                // is 0 for white (transparent) and 255 for black (opaque).
                // This matches what the model expects.
                const data = imageData.data;
                const buffer = new Float32Array(28 * 28);
                for (let i = 0; i < data.length / 4; i++) {
                    buffer[i] = data[i * 4 + 3] / 255.0; // Use alpha channel and normalize
                }

                // d. Reshape to [1, 28, 28, 1] (1 image, 28x28, 1 channel)
                return tf.tensor(buffer, [1, 28, 28, 1]);
            });

            // 2. Make the prediction
            const predictions = model.predict(tensor);
            
            // 3. Get the prediction data as a normal array
            const pData = await predictions.data();
            
            // 4. Find the highest probability
            const maxProb = Math.max(...pData);
            const digit = pData.indexOf(maxProb);

            // 5. Update the UI
            resultText.innerText = digit;
            updateProbabilities(pData);
            
            // 6. Dispose tensors
            tf.dispose([tensor, predictions]);
        }

        /**
         * Updates the probability bar chart in the UI.
         */
        function updateProbabilities(data) {
            for (let i = 0; i < data.length; i++) {
                const prob = data[i] * 100;
                const bar = document.getElementById(`prob-bar-${i}`);
                const val = document.getElementById(`prob-val-${i}`);
                
                bar.style.width = `${prob}%`;
                val.innerText = `${prob.toFixed(1)}%`;

                // Highlight the max probability
                if (prob.toFixed(1) === (Math.max(...data) * 100).toFixed(1)) {
                    bar.classList.add('bg-green-500');
                    bar.classList.remove('bg-blue-500');
                } else {
                    bar.classList.add('bg-blue-500');
                    bar.classList.remove('bg-green-500');
                }
            }
        }

        // --- Start the app ---
        init();

    </script>
</body>
</html>
